/*
 * $Id: KBDialect.java,v 1.1 2010/08/24 06:54:43 zhaoqy Exp $
 *
 * Copyright (c) 2010 ChinaSoft International, Ltd. All rights reserved
 * ResourceOne BizFoundation Project
 * 
 */
package org.ganjp.core.db.dialect;
/**
 * @author Rone Framework Team : yanghuan
 * 
 * 人大金仓数据库方言
 * 
 * @version Revision: 1.0
 * @since 4.0
 * @param <KBDialect>
 */
public class KBDialect extends DBDialect {

	public KBDialect() {
		super();
	}

	public String getAddColumnString() {
		return "add column";
	}

	public String getSequenceNextValString(String s) {
		return "select nextval ('" + s + "')";
	}

	public String getCreateSequenceString(String s) {
		return "create sequence " + s;
	}

	public String getDropSequenceString(String s) {
		return "drop sequence " + s;
	}

	public String getCascadeConstraintsString() {
		return "";
	}

	public boolean supportsSequences() {
		return true;
	}

	public String getQuerySequencesString() {
		return "select relname from sys_class where relkind='S' and relacl is null";
	}

	public boolean supportsLimit() {
		return true;
	}

	public String getLimitString(String s, boolean flag) {
		return (new StringBuffer(s.length() + 20)).append(s).append(
				flag ? " limit ? offset ?" : " limit ?").toString();
	}

	public boolean bindLimitParametersInReverseOrder() {
		return true;
	}

	public boolean supportsIdentityColumns() {
		return true;
	}

	public String getIdentitySelectString(String s, String s1, int i) {
		return "select currval('" + s + '_' + s1 + "_seq')";
	}

	public String getIdentityColumnString(int i) {
		return i != -5 ? "serial not null" : "bigserial not null";
	}

	public boolean hasDataTypeInIdentityColumn() {
		return false;
	}

	public String getNoColumnsInsertString() {
		return "default values";
	}

	public boolean supportsOuterJoinForUpdate() {
		return false;
	}

	public boolean useInputStreamToInsertBlob() {
		return false;
	}

	public boolean supportsUnionAll() {
		return true;
	}

	public boolean supportsCommentOn() {
		return true;
	}

	public boolean dropConstraints() {
		return false;
	}

	public String getIdentitySelectString(String table) {
		return "values IDENTITY_VAL_LOCAL()";
	}

	public String getIdentityColumnString(String table) {
		return "not null generated by default as identity";
	}

	public String getIdentityInsertString(String table) {
		return "default";
	}

	public String getAlterSequencesString(String sequenceName, long newValue) {
		return "alter sequence " + sequenceName + " restart with "
				+ String.valueOf(newValue);
	}

	public String getQuerySequencesString(String sequenceName) {
		return "select relname from SYS_CLASS where relname = '"
				+ sequenceName.toUpperCase() + "'";
	}

	public String getCountResultString(String querySql) {
		StringBuffer buf = new StringBuffer();
		buf.append("select count(*) from (");
		buf.append(querySql);
		buf.append(") wrapped__");
		return buf.toString();
	}

	static int getAfterSelectInsertPoint(String sql) {
		int selectIndex = sql.toLowerCase().indexOf("select");
		int selectDistinctIndex = sql.toLowerCase().indexOf("select distinct");
		return selectIndex + (selectDistinctIndex != selectIndex ? 6 : 15);
	}

	public String getLimitString(String query, int offset, int limit) {
		return (new StringBuffer(query.length() + 8)).append(query).insert(
				getAfterSelectInsertPoint(query),
				" top " + offset + "," + limit + " ").toString();
	}

	public static String getRowNumber(String sql) {
		StringBuffer rownumber = new StringBuffer(50)
				.append("rownumber() over(");
		int orderByIndex = sql.toLowerCase().indexOf("order by");
		if (orderByIndex > 0 && !hasDistinct(sql)) {
			String orderBy = sql.substring(orderByIndex);
			int point = orderBy.indexOf(".");
			if (point != -1) {
				orderBy = " order by " + orderBy.substring(point + 1);
			}
			rownumber.append(orderBy);
		}
		rownumber.append(") as rownum__");
		return rownumber.toString();
	}

	private static boolean hasDistinct(String sql) {
		return sql.toLowerCase().indexOf("select distinct") >= 0;
	}

	public boolean isSupportAlterSequenceRestart() {
		return true;
	}

	public String getBeforeAlterSequenceRestart(String seqname) {
		return null;
	}
}